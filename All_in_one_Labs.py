def PassCheck(): # 2.1 Пользовательский ввод
    # 2.1 При регистрации на сайтах требуется вводить пароль дважды.
    # Это сделано для безопасности, поскольку такой подход уменьшает возможность неверного ввода пароля.
    # Напишите программу, которая сравнивает пароль и его подтверждение.
    # Если они совпадают, то программа выводит: «Пароль принят», иначе: «Пароль не принят».

    a = input("Введите пароль") # Сохраняем в переменную введённый пароль
    b = input("Повторите пароль") # Сохраняем в переменную повторно введённый пароль
    if a == b: # Сопоставляем пароли
        print("Пароль принят")
        return 1
    else:
        print("Пароль не принят")
        return 0

def PlaceCheck(): # 2.2 Работа с числами
    # 2.2 Напишите программу, которая определяет, какой тип места в плацкартном вагоне (верхнее или нижнее, в купе или боковое)
    # по заданному номеру места.

    e = int(input("Введите номер места")) # Вводим номер места
    kupe = range(1, 37) # Задаём диапозон мест для купе
    bok = range(37, 55) # Задаём диапозон для боковых мест
    if e > 0 and e < 55: # Проверяем, что введённое место существует
        if e in kupe: # Проверяем, входит ли введённое число в диапозон мест в купе
            print("Купе")
        if e in bok: # Проверяем, входит ли введённое число в диапозон мест сбоку
            print("Боковое")
        if e % 2 == 0: # Проверяем, делится ли введённое число на 2 без остатка
            print("Верхнее")
        else:
            print("Нижнее")
    else:
        print("Нет такого места")

def YearChk(): # 2.3 Продолжение работы с числами
    # 2.3 Год является високосным, если его номер кратен 4, но не кратен 100, или если он кратен 400.
    # Напишите функцию, которая определяет, является ли год с данным номером високосным.
    # Если год  является високосным, то выведите «Год ... - високосный», где вместо
    # многоточия выведите год, иначе выведите «Это год не високосный».

    a = int(input("Введите год")) # Вводим год
    if a % 4 == 0 and a % 100 != 0 or a % 400 == 0:
        print("Год " + str(a) + " - високосный")
        return 1
    else:
        print("Этот год не високосный")
        return 0

def MixColor(): #  2.4 Продолжение работы с числами
    # 2.4 Красный, синий и желтый называются основными цветами,a потому что их нельзя получить путем смешения других цветов.
    # При смешивании двух основных цветов получается вторичный цвет:
    # - если смешать красный и синий, то получится фиолетовый;
    # - если смешать красный и желтый, то получится оранжевый;
    # - если смешать синий и желтый, то получится зеленый.
    # Напишите программу, которая считывает названия двух основных цветов для смешивания.
    # Если пользователь вводит что-нибудь помимо названий «красный», «синий» или «желтый», то программа должна
    # вывести сообщение об ошибке. В противном случае программа должна
    # вывести название вторичного цвета, который получится в результате.

    # Для решение задачи в первой части функции каждому цвету присвоим определённое уникальное число.
    # Затем во второй части сложем полученные два числа и найдём соответствие
    c = 2 # Количество циклов ввода
    b = 0 # Сумма первого и второго цвета
    while c > 0: # Пока не будут введены оба цвета
        a = str(input("Введите цвет"))
        if a == "красный" or a == "желтый" or a == "синий": # Проверяем соответствие указанного цвета
            if a == "красный":
                b = b + 5
            if a == "желтый":
                b = b + 10
            if a == "синий":
                b = b + 20
        else: # При несовпадении
            print("Можно вводить только цвета: красный, желтый, синий")
            b = 0 # Обнуляем сумму цветов (Чтобы не было ошибки при проверке итоговой суммы)
            break # Останавливаем выполнение
        c = c - 1
    if b == 10:
        print("Результат смешения: Красный")
    if b == 20:
        print("Результат смешения: Желтый")
    if b == 40:
        print("Результат смешения: Синий")
    if b == 15:
        print("Результат смешения: Оранжевый")
    if b == 25:
        print("Результат смешения: Фиолетовый")
    if b == 30:
        print("Результат смешения: Зеленый")

def KeyInput(): # 3.1 Пользовательский ввод и цикл
    # С клавиатуры вводятся поочередно N слов.
    # Напишите программу, которая соединяет эти слова в одну длинную строку,
    # разделяя слова пробелами. Используйте операторы цикла.

    a =0 # Переиенная для хранения вводимого слова
    b="" # Переменная для хранения введённых слов
    while a != "": # Пока пользователь не оставит поле ввода пустым
        a = str(input("Введите слово")) # Запрашиваем новое слово
        b = b + str(a) + " " # И добавляем его через пробел к уже имеющемуся
    print(b) # Выводим все введённые слова

def WordChk(): # 3.2 Пользовательский ввод и цикл с проверкой на введённое слово
    # Модифицируйте предыдущую программу так, чтобы число вводимых слов не было задано,
    # а программа работала до того момента, как пользователь введет слово «stop».

    a = 0 # Переиенная для хранения вводимого слова
    b = "" # Переменная для хранения введённых слов
    while a != "stop": # Пока пользователь не введёт слорво "стоп"
        b = b + str(a) + " " # И добавляем его через пробел к уже имеющемуся
        a = str(input("Введите слово")) # Запрашиваем новое слово
    print(b) # Выводим все введённые слова

def LetChk(): # 3.3 Проверка наличия буквы в слове
    # В игре в слова ценится наличие редких букв в словах.
    # Считается, что буква "ф" встречается в русском языке реже всех остальных.
    # Напишите программу, которая позволяет пользователям
    # вводить какие-либо слова и проверяет, можно считать это слово редким или нет.
    # Редкими будем считать слова, которые содержат букву "ф".
    # Пусть эта программа выводит на экран одну из двух фраз:
    # "Ого! Это редкое слово!", если в слове есть буква "ф",
    # или "Эх, это не очень редкое слово...", если в нём этой буквы нет.

    a = str(input("Введите слово"))
    b = len(a) # Узнаём длинну введённого слова
    c = "" # Инициализируем переменную С для хранения в ней символов
    while b >= 0: # Слово будем разбирать с конца. Поэтому пока длинна слова не будет равна 0
        c = a[b:b + 1] # Задаём координаты симвроа, который требуется проверить
        if c == "ф": # Проверяем, является ли символ буквой "Ф"
            print("Ого! Это редкое слово!")
            b = -1 # Если да - устанавливаем отрицательное значение длинны слова, что прервёт цикл, не разбирая слова до конца
        b = b - 1 # Отнимаем 1 от длинны слова
        if b == -1:
            print("Эх, это не очень редкое слово")

def MathGame(): # 3.4 Математическая игра
    # Напишите программу-игру «Математика для детей»:
    # компьютер выводит выражение-сумму двух чисел, например: 3 + 5 =
    # Пользователь должен ввести ответ (курсор должен оставаться в nодной строке с заданным выражением).
    # Если ответ правильный, то вывести сообщение после результата «Правильно!»,
    # если ответ неправильный, то вывести сообщение «Ответ неверный».
    # Игра продолжается в цикле до тех пор, пока пользователь не сделает 3 ошибки.
    # После этого вывести сообщение: «Игра окончена. Правильных ответов: …» -
    # вместо многоточия вывести количество правильных ответов.

    import random # Модуль для рандомизации чисео и не только
    c = 3 # Количество оставшихся попыток
    e = 0 # Количество правильных ответов
    while c > 0: # Пока остаются попытки
        a = random.randint(1, 27) # Рандомизируем оба числа в
        b = random.randint(1, 27) # диапозоне от 1 до 27
        d = int(input(str(a) + " + " + str(b) + " =")) # Выводим пртимер на зкран и предлагаем пользователю ввести ответ
        if a + b == d: # Если ответ пользователя совпал с суммой рандомизированных чисел -
            e = e + 1 # Добавляем 1 правильный ответ
            print("Правильно!")
        else:
            c = c - 1 # Иначе отнимаем одну попытку
            print("Ответ неправильный.")
    print("Игра окончена! Правильных ответов - " + str(e))

def code(x,y): # 4.1 Работа с функциями. Деление без остатка
    # 4.1 Напишите функцию, которая проверяет, делится ли введенное число на 3, или нет.

    if x % y == 0:
        x = 0
        print("Делится без остатка")
    else:
        print("Не делится без остатка")
    return x

def code(x): # 4.2 Проверка типа переменной
    # Напишите программу деления числа 100 на введенное пользователем число.
    # Деление реализуйте с помощью функции.
    # Предусмотрите возможные исключения (ValueError, возникающее в случае, если пользователь введет не число, а строку,
    # и ZeroDivisionError – если будет введено число 0 и остальные).

    if x.isdigit() == True and int(x) != 0:
        x = 100 / int(x)
    else:
        x="ERROR"
    return x

def code(x): # 4.3 Парсинг числа
    # Напишите функцию, которая возвращает True, если введенная пользователем дата является магической, и False в обратном случае.
    # Магической считается дата, в которой произведение дня и месяца равно двум последним цифрам года, например:
    # 02.11.2022.

    d = ""
    d = int(x[0:2]) * int(x[3:5]) # Умножаем день на месяц
    if int(d) == int(x[8:10]): # Сравниваем с двумя последними числами года
        x="true"
    else:
        x="false"
    return x

def code(x): # 4.4 Счастливый билет. Парсинг числа
    # 4.4 "Счастливым" называют билет с номером, в котором сумма первой половины цифр равна сумме второй половины цифр.
    # Номера могут быть произвольной длины, с единственным условием, что количество цифр всегда чётно, например: 33 или 2341 и так далее.
    # Билет с номером 385916 — счастливый, так как 3 + 8 + 5 == 9 + 1 + 6.
    # Билет с номером 231002 не является счастливым, так как 2 + 3 + 1 != 0 + 0 + 2
    # Реализуйте функцию, проверяющую является ли номер счастливым (номер — всегда строка).

    count = len(x) # Узнаём длинну входного числа
    count1 = int(len(x)) # Дублируем значение
    summa1 = 0 # Сумма первой половине числа
    summa2 = 0 # Сумма второй половины числа
    if int(count) % 2 == 0: # Проверяем длину числа на чётность
        count = count - 1
        while count >= 0: # Начинаем парсить число с конца
            if count >= count1 / 2: # Парсим и суммируем вторую половину числа
                summa1 = summa1 + int(x[count:count + 1])
            else: # Парсим и суммируем первую половину числа
                summa2 = int(summa2) + int(x[count:count + 1])
            count = count - 1
        if (summa1 == summa2):
            x="Счастливый"
        else:
            x = "Несчастливый"
    else:
        x = "Количество цифр в билете должно быть четно"
    return x

import random
#a - количество чисел, b - от скольки, с - до скольки
def randomizer(a, b, c): # 5.1 Работа с рандомайзером
    # 5.1 Создайте список из пяти любых чисел.
    # Спросите у пользователя число. Проверьте, есть ли данное число в списке.
    # Выведите исходный список, число пользователя и соответствующие сообщение ("Поздравляю, Вы угадали число!" или "Нет такого числа!").

    # a - количество чисел, b - от скольки, с - до скольки
    count = 1
    RandomNumbers=""
    while count <= a:
        #random а дальше как рандомизировать, randint - целые числа
        RandomNumbers = RandomNumbers + str(random.randint(b, c)) + " "
        count += 1
    return RandomNumbers

def Arrays(): # 5.2 Работа с массивами
    mass = [0, 99]
    count = 0
    UserInp = ""
    while UserInp != "стоп":
        UserInp = input(str(count) + "-й элемент списка")
        if UserInp != "стоп":
            mass[count] = UserInp
        else:
            break
        print(mass[count])
        count += 1

def Weekends(): # 5.3 Работа со списками
    # 5.3 Задан кортеж с перечнем названий дней недели. Спросить у
    # пользователя, сколько выходных на неделе он хочет и вывести два списка:
    # "Ваши выходные дни: ..." - перечислить здесь столько дней недели с конца кортежа, сколько введено пользователем.
    # "Ваши рабочие дни: ..." - перечислить здесь оставшиеся дни недели.

    tuple = ('понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота', 'воскресенье')
    b = ""
    a = int(input("Введите число, сколько вы хотите выходных в неделю"))
    a = 7 - a
    b = tuple[0:a]
    a = tuple[a:7]
    print("Ваши выходные:" + str(a))
    print("Ваши рабочие дни:" + str(b))

def StudentsTeam(): # 5.4 Работа со списками
    # 5.4 Создайте два списка: один из 10 фамилий студентов Вашей группы, другой из 10 фамилий студентов другой группы.
    # Создайте спортивную команду (объедините в один кортеж) по 5 любых студентов из каждой группы.
    # Выведите на экран исходные списки групп и новый полученный кортеж.
    # c. Выведите его длину.
    # d. Отсортируйте кортеж по алфавиту.
    # e. Определите, входит ли в полученную команду студент "Иванов".
    # И сколько раз встречается эта фамилия в кортеже

    import random
    List1 = ["Котова", "Малова", "Игнатьев", "Прохоров", "Сергеев", "Леонтьев", "Денисова", "Лис", "Чапов", "Литин"]
    List2 = ["Уральский", "Ланитов", "Сурков", "Михеева", "Сереннкова", "Рена", "Алешина", "Иванов", "Бруеван",
             "Дачник"]
    a = (random.sample(List1, 5) + random.sample(List2, 5))
    print("Исходный список 1 группы:" + (str(List1)))
    print("Исходный список 2 группы:" + (str(List2)))
    print("Кортеж спортивной команды:" + (str(a)))
    print("Длина кортежа = " + (str(len(a))))
    b = sorted(a)
    Ivanov = 0
    familia = ''
    for familia in a:
        if familia == "Иванов":
            Ivanov += 1
    print(b)
    print("Фамилия Иванов встречается в команде " + (str(Ivanov)) + " раз.")

def Countries(): # 6.1 Работа со словарями
    # 6.1 Создайте словарь, содержащий перечень стран и их столиц.
    # a) Выведите на экран все пары ключ-значение.
    # b) Выведите на экран столицу для определенной страны.
    # c) Отсортируйте и выведите на экран содержимое словаря в
    # алфавитном порядке названий стран.

    Страны = {"Новая Зеландия": "Веллингтон", "Норвегия":"Осло","ОАЭ":"Дубай","Португалия":"Лиссабон","США":"Вашингтон","Южная Корея": "Сеул","Канада":"Оттава","Испания": "Мадрид", "Япония":"Токио","Тайланд": "Бангок"}
    print("Список всех стран:\n" + str(Страны) + "\nОтсортированный список стран:\n" + str(sorted(Страны)) + "\nСтолица Вашей страны - "+ str(Страны.get(input("Введите страну"), "в моём списке такого нет")))

def Erudit(): # 6.2 Игра "Эрудит"
    # 6.2 В игре в слова «Эрудит» каждая буква имеет определенную ценность:
    # А, В, Е, И, Н, О, Р, С, Т – 1 очко;
    # Д, К, Л, М, П, У – 2 очка;
    # Б, Г, Ё, Ь, Я – 3 очка;
    # Й, Ы – 4 очка;
    # Ж, З, Х, Ц, Ч – 5 очков;
    # Ш, Э, Ю – 8 очков;
    # Ф, Щ, Ъ – 10 очков.
    # Напишите программу, которая вычисляет стоимость введенного пользователем слова.

    словарь = {"а": "1", "б": "3", "в": "1", "г": "3", "д": "2", "е": "1", "ё": "3", "ж": "5", "з": "5", "и": "1",
               "к": "2", "л": "2", "м": "2", "н": "1", "о": "1", "п": "2", "р": "1", "с": "1", "т": "1", "у": "2",
               "ф": "10", "х": "5", "ц": "5", "ч": "5", "ш": "8", "щ": "10", "ъ": "10", "ы": "4", "ь": "3", "э": "8",
               "ю": "8", "я": "3"}
    a = input("Введите слово: ")
    b = len(a) # Узнаём длинну введённого слова
    points = 0 # очки за букву
    c = "" # Переменная для хранения разбираемого символа
    while b >= 0: # Разбираем с конца
        c = a[b:b + 1]
        for d in словарь:
            if d == c: # Сопоставляем разбираемый символ с ключами из словаря
                points += int(словарь.get(d, 0))
        b -= 1
    print(points)

def Lang(): # 6.3 * Расширенная работа со словарём
    # 6.3 *Доп.задание на множество. Есть множество студентов. Каждый из них знает некоторое количество языков.
    # Нужно определить сколько различных языков знают студенты.
    # Выведите отсортированный список этих языков.
    # Выведите список студентов, которые знают китайский язык.

    Langs = {"Китайский": "1", "Французкий": "2", "Немецкий": "3", "Английский": "4", "Русский": "5", "Хинди": "6"}
    Studs = {"Иванов": "135", "Петров": "134", "Сидоров": "24", "Паронько": "12345", "Зубрилкин": "34",
             "Хулиганов": "5", "Полиглотов": "12345", "Кодер": "4", }
    StudsKeys = Studs.keys()  # Получаем Ключи-имена студентов
    print(StudsKeys)  # Это пригодится для создания списка всех языков, которые знают студенты
    StudsLangs = []  # Создаём список из всех языков, которые знают студенты
    for Student in StudsKeys:
        StudsLangs.append(Studs.get(Student))  # Получаем список из индексов языков
    print(StudsLangs)
    # Теперь избавимся от повторов. Для этого сначала склеим все языки в одной переменной
    LangsCount = ""
    for Temp in StudsLangs:
        LangsCount += str(Temp)  # Склеиваем все индексы в один большой
    print(LangsCount)
    # Мы получили длинное число. Убираем из него повторяющиеся элементы
    Temp = 9
    # Создаём цикл. Если номер цикла совпадёт с числом в переменной - выписываем число и немедленно
    # переходим к следующему шагу цикла
    Temp2 = ""
    while Temp >= 0:
        for Temp1 in LangsCount:
            if int(Temp1) == int(Temp):
                Temp2 += Temp1
                break
        Temp -= 1
    LangsCount = Temp2
    print(LangsCount)  # Мы получили индексы всех известных языков
    # Теперь выведем колиество этих различных языков
    print(len(LangsCount))
    # Создаём список из языков, которые знают студенты.
    # Для удобства взаимодействия поменяем ключ и значение местами в словаре языков
    LangsRevers = dict(zip(Langs.values(), Langs.keys()))
    print(LangsRevers)  # Теперь можно выполнять поиск по индексу в новом словаре
    # Теперь распарсим переменную LangsCount, где хранятся индексы языков и Вытащим нужные языки из словаря
    KnownLangs = []  # Список для известных языков
    for Temp in LangsCount:
        KnownLangs.append(LangsRevers.get(Temp))
    print(KnownLangs)
    # Отсортируем получившийся список
    KnownLangs.sort()
    print(KnownLangs)
    # Теперь выведем список студентов, которые знают введённый язык
    SrcLang = input("Введите интересующий язык")
    # Для этого в словаре найдём соответствующий указанному языку индекс
    SrcLangIndex = Langs.get(SrcLang)
    print(SrcLangIndex)  # Мы вытащили индекс интересующего языка
    # Для удобства так же перевернём словарь со студентами
    StudsRevers = dict(zip(Studs.values(), Studs.keys()))
    print(StudsRevers)
    Final = []
    # Теперь разберём ключи-индексы, присвоенные студентам и найдём в них соответствующий нашему
    for Temp in StudsRevers:  # За один цикл получаем все языки, которые знает студент
        for Temp1 in Temp:  # А в этом подцыкле проверяем, есть ли среди всех них нужный нам
            if Temp1 == SrcLangIndex:  # Если нашли совпадения - Добавляем студента по ключу из перевёрнутого словаря
                Final.append(StudsRevers.get(Temp))
    print(Final)

# Прописать в консоли pip install pillow для работы модулей
# импортируем модули
from PIL import Image # Работа с фото
from PIL import ImageFont # Работа со шрифтами
from PIL import ImageDraw # Создание новых фото
from PIL import ImageFilter #  Работа с фильтрами
from PIL.ExifTags import TAGS # Работа с exif тэгами
import os
import csv
import json



def PictShowing(path): # 7.1 Выводим фото на экран
    # Подготовьте любой графический файл для выполнения практической работы.
    # Напишите программу, которая открывает и выводит этот файл на экран.
    # Получите и выведите в консоль информацию о размере изображения, его формате, его цветовой модели.
    picture = Image.open(path) # Открываем фото в переменной
    picture.show() # Выводим фото на экран

def PictPrintInfo(path): # 7.1 Печать информации о фото
    picture = Image.open(path)  # Открываем фото в переменной
    print(picture.filename)  # Отображаем путь к фото в коноли
    print(picture.format) # Выводим информацию о формате фото
    print(picture.size) # Выводим информацию о размере фото
    print(picture.mode) # Выводим информацию о цветовой схеме фото
    print(type(picture))
    exifdata = picture.getexif() # Выводим информацию о дате, устройстве захвата и т.д.
    for tagid in exifdata: # Парсим exif данные
        tagname = TAGS.get(tagid, tagid)
        value = exifdata.get(tagid)
        print(f"{tagname:25}: {value}")
    print(picture.__dict__)

def PictTransp(path): # 7.2 Отзеркаливание фото
    # Напишите программу, которая создаёт уменьшенную в три раза копию изображения.
    # Получите горизонтальный и вертикальный зеркальный образ изображения.
    # Сохраните изображения в текущую папку под новым именем.
    picture = Image.open(path)  # Открываем фото в переменной
    picture = picture.reduce(3)  # уменьшаем фото в 3 раза
    picture.show()  # Выводим фото на экран
    picture = Image.open(path)  # Открываем фото в переменной
    picture = picture.transpose(0) # Зеркалим фото по горизонтали
    picture.show()
    picture = Image.open(path)  # Открываем фото в переменной
    picture = picture.transpose(5) # Зеркалим фото по вертикали
    picture.show()

def PictFilterRGB(path): # 7.3 Наложить фильтр (альтернативный способ методом изменения очерёдности цветовых каналов)
    picture = Image.open(path) # Открываем фото в переменной
    r, g, b = picture.split() # Раскладываем фото на цветовые каналы
    picture = Image.merge(mode="RGB", bands=(r, b, g)) # Собираем цветовые каналы в другой очередности
    picture.show() # Выводим фото на экран
    picture.save("redacted.JPG")  # Сохраняем фото

def PictSharp(): # 7.3 9.1(Модифицировать) 9.2 (Модифицировать) Наложить фильтр
    # Подготовьте 5 графических файлов с именами 1.jpg, 2.jpg, 3.jpg, 4.jpg, 5.jpg.
    # Напишите программу, которая применит ко всем этим файлам сразу любой фильтр (кроме размытия,
    # т.к. он рассматривался на лекции).
    # Сохраните изображения в новую папку под новыми именами.
    # 9.1 - Модифицируйте программу из практики 7.3 (7 лабораторная работа ) или создайте заново:
    # обработать любой операцией все картинки в заданной папке, используя для обхода файлов в папке модуль os (или Pathlib).
    # При этом каталог для итоговых (обработанных) изображений должен тоже создаваться с помощью модуля os или Pathlib.
    # 9.2 - Модифицировать программу из практики 9.1, добавив проверку типа (расширения) файла,
    # если в папке хранятся разные типы файлов, а вам нужно обработать только заданные (jpg, png).
    # Модификация 9.1:
    if not os.path.isdir("LabFiles/Redacted"): # Проверяем существование каталога
        os.mkdir("LabFiles/Redacted")  # Создаём новый каталог в случае его отсутствия.
    ListOfFiles = os.listdir("LabFiles") # Добавляем все файлы корневого каталога в переменную список
    for format in ListOfFiles:  # Читаем список в переменную "формат" с помощью цикла
        # Модификация 9.2
        if ".jpg" in format or ".png" in format: # Ищем файлы с нужными расширениями. Если раширение подошло:
            # Выполяем 7.3
            picture = Image.open(format) # Открываем фото в переменной по значению из списка
            picture = picture.filter(ImageFilter.SHARPEN) # Накладываем фильтр повышения резкости
            picture.show() # Выводим фото на экран
            picture.save(str("LabFiles/Redacted/NEW___") + str(format))  # Добавляем "NEW___" к имени файла и сохраняем его.

def watermarkPict(input_image_path, output_image_path, watermark_image_path, positionX, positionY): # 7.4 Наложение водяного знака
    # Напишите программу, которая добавляет на изображение водяной знак.
    base_image = Image.open(input_image_path) # Открываем исходное фото в переменной
    watermark = Image.open(watermark_image_path) # Открываем водяной знак в переменной
    width, height = base_image.size # Читаем размеры исходника в переменную
    transparent = Image.new('RGBA', (width, height), (0, 0, 0, 0)) # Создаём новое фото с размерами исходника (прозрачное RGBA)
    transparent.paste(base_image, (0, 0)) # Накладываем на него исходник
    transparent.paste(watermark, (positionX, positionY), mask=watermark) # Накладываем водяной знак на новое фото
    transparent.show() # Отображаем получившийся файл
    transparent.save(output_image_path) # Сохраняем получившийся файл

def PictCrop(path, x1, y1, x2, y2): # 8.1 Обрезка фото
    # Скачайте любую открытку из интернета, определите область,
    # которую Вам нужно вырезать из данного изображения (обрезать текст, часть фото и т.д.).
    # Напишите программу, которая выполнит эту операцию.
    # Сохраните изображения в текущую папку под новым именем.
    picture = Image.open(path)  # Открываем фото в переменной
    print(picture.size) # Печатаем размеры фото (для удобства подгонки размеров вырезаемой области)
    picture = picture.crop((x1, y1, x2, y2)) # Обрезаем фото по заданным координатам.
    picture.show() # Открываем обрезанное фото
    picture.save("Открытка ОБРЕЗАНО.png") # Сохраняем обрезанное фото под новым именем.

# Словари для 8.2 и 8.3
# Словарь праздник - путь к фото открытки к празднику
CelebsPath = {"новый год": "LabFiles/Открытки/6.JPEG", "день рождения": "LabFiles/Открытки/7.JPG", "23 февраля": "LabFiles/Открытки/8.JPG", "8 марта": "LabFiles/Открытки/9.JPG"}
# Словарь праздник - его склонение
CelebsText = {"новый год": "Новым годом, ", "день рождения": "Днём рождения, ", "23 февраля": "23-ем февраля, ", "8 марта": "8-ым марта, "}
# Словарь праздник - координаты текста по Х для открытки
CelebsCoordX = {"новый год": 350, "день рождения": 620, "23 февраля": 200, "8 марта": 220}
# Словарь праздник - координаты текста по У для открытки
CelebsCoordY = {"новый год": 500, "день рождения": 900, "23 февраля": 500, "8 марта": 165}

def  Congrats(celeb, conname): # 8.2 8.3(Модифицировать)
    # Создайте словарь, содержащий перечень пары «Название праздника – имя_файла с открыткой к нему».
    # Спросите у пользователя, к какому празднику ему нужна открытка и выведите нужную открытку наэкран.
    # 8.3 - Модифицируйте задачу 8.1 так: спросите еще у пользователя,
    # имя того, кого он хочет поздравить, добавьте на заданную открытку
    # текст «…., поздравляю!», где вместо …. вставьте полученное
    # имя (выведите его разным цветом и шрифтами, посередине вверху или внизу фото).
    # Найдите в сети интернет решение, как сделать надпись жирным текстом (по умолчанию, такого параметра нет).
    # Сохраните новую открытку в файл с расширением png.
    path = CelebsPath.get(celeb) # Получаем путь к открытке
    print("Путь к файлу - "+ str(path)) # Выводим путь (отладка)
    ConText = CelebsText.get(celeb) # Получаем текст поздравления
    print("Текст поздравления - "+ str(ConText)) # Выводим текст поздравления (отладка)
    CelebCoordX = CelebsCoordX.get(celeb) # Получаем координаты по Х
    print("Координаты текста по Х - "+ str(CelebCoordX)) # Выводим координаты по Х (отладка)
    CelebCoordY = CelebsCoordY.get(celeb) # Получаем координаты по У
    print("Координаты текста пл У - "+ str(CelebCoordY)) # Выводим координаты по У (отладка)
    print("Имя получателя - "+ str(conname)) # Выводим имя получателя (отладка)
    font_fname = '/fonts/Arial/arial.ttf'  # Прописываем путь к основеому шрифту
    font_fname_bold = '/fonts/Arial/arialbd.ttf'  # Прописываем путь к жирному шрифту
    font_size = 70  # Устанавливаем размер шрифта
    font = ImageFont.truetype(font_fname, font_size)  # Устанавливаем стиль для обычного текста
    font_bold = ImageFont.truetype(font_fname_bold, font_size)  # Устанавливаем стиль для жирного текста
    with Image.open(path) as picture: # Открываем изображение в переменной
        draw = ImageDraw.Draw(picture) # Создаём но новое фото в объекте draw
        draw.text(xy=(CelebCoordX, CelebCoordY), text="Поздравляю с ", font=font, fill=(0, 255, 0)) # Пишем зелёным шрифтом
        TL = font.getlength("Поздравляю с ") # Вычисляем длинну написанного текста указанным шрифтом
        draw.text(xy=(CelebCoordX + TL, CelebCoordY), text=ConText + " ", font=font, fill=(0, 0, 255)) # Пишем Голубым шрифтом
        TL = TL + font.getlength(ConText) # Вычисляем длинну написанного текста указанным шрифтом
        draw.text(xy=(CelebCoordX + TL, CelebCoordY), text=conname, font=font_bold, fill=(255, 0, 0)) # Пишем Красным шрифтом
    picture.show() # Вывоим полученное изображение на экран
    picture.save("Открытка с " + str(ConText) + ".png")# Сохраняем полученное изображение
def Pokupki(path): # 9.3 Работа с CSV файлами
    # Имеется файл с данными в формате csv:
    # Продукт,Количество,Цена
    # Молоко,2,80
    # Сыр,1,500
    # Хлеб,2,70
    # Напишите программу, которая считывает данные из этого файла,
    # подсчитывает итоговую сумму расходов и выводит данные в виде:
    # Нужно купить:
    # Молоко - 2 шт. за 80 руб.
    # Сыр - 1 шт. за 500 руб.
    # Хлеб - 2 шт. за 70 руб.
    # Итоговая сумма: 800 руб.
    print("Нужно купить")
    Price=0 # Будущая итоговая цена
    with open(path, encoding='utf-8') as r_file: # Открываем файл в переменной "r_file"
        file_reader = csv.reader(r_file, delimiter=";") # Создаем объект reader, указываем символ-разделитель ";"
        count = 0 # Счётчик строк, чтобы первая строка не считалась в в переменную
        for row in file_reader: # Построчно читаем файл в переменную "row"
            if count != 0: # Проверяем, что читается не первая строка файла
                Price = int(Price) + (int(row[2]) * int(row[1])) # К предыдущей цене добавляем новую цену, умноженную на кол-во штук
                # Цена =    Цена   + (цена товара * кол-во штук)
                print(f' {row[0]} - {row[1]} шт. за {row[2]} руб.')
            # Печать   имя товара - кол-во   шт за    цена    руб.
            count += 1 # Увеличиваем счётчик строк
    print(f' Итоговая сумма {Price} Руб.') # выводим итоговую цену

def JSON(path): # 10.1 10.2 Работа с JSON Файлами
    # 10.1 Имеется файл JSON с информацией о продуктах:
    # {
    #  "products": [
    # {
    # "name": "Шоколад",
    # "price": 50,
    # "available": true,
    # "weight": 100
    # },
    # {
    # "name": "Кофе",
    # "price": 100,
    # "available": false,
    # "weight": 250
    # },
    # {
    # "name": "Чай",
    # "price": 70,
    # "available": true,
    # "weight": 50
    # }
    #  ]
    # }
    # Напишите программу, которая считывает информацию из этого файла и выводит ее на экран в виде:
    # Название: Шоколад
    # Цена: 50
    # Вес: 100
    # В наличии
    # Название: Кофе
    # Цена: 100
    # Вес: 250
    # Нет в наличии!
    # Название: Чай
    # Цена: 70
    # Вес: 50
    # В наличии
    with open(path, encoding='utf-8') as JsonFile: # Открываем файл в переменной JsonFile
        reader = json.load(JsonFile) # Читаем файл в переменную
    print(reader)
    print(type(reader))
    ProductsList = reader.get("products") # Словарь продукты содержми список из словарей
    print(ProductsList) # Смотрим список словарей
    print(type(ProductsList))
    ProductsDict = ProductsList[1] # Берём для проверки первый словарь из списка
    print(ProductsDict) # Получаем продукты из первого словаря
    print(type(ProductsDict))
    # То есть структура файла следующая:
    # Продукты(Словарь)                reader
    #   1. Продукты: Список            ProductsList
    #          1. Словарь              ProductsDict
    #          2. Словарь              ProductsDict
    #          3. Словарь              ProductsDict
    # Теперь выполним все те же действия для остальных словарей
    ProductsListLen = (len(ProductsList)) # Узнаём количество элементов в списке
    count = 0
    while count != ProductsListLen:
        ProductsDict = ProductsList[count]  # Берём словарь из списка
        print(f' Название: {ProductsDict.get("name")}')  # Получаем имя продукта из словаря
        print(f' Цена: {ProductsDict.get("price")}')  # Получаем имя продукта из словаря
        print(f' Вес: {ProductsDict.get("weight")}') # Получаем вес продукта из списка
        if ProductsDict.get("available") == True: # Проверяем наличие продукта
            print("В наличии")
        if ProductsDict.get("available") == False:
            print("Нет в наличии!")
        print(" ") # Добавляем пустую строку между позициями
        count += 1 # Следующий цикл
    # 10.2 Модифицируйте программу 10.1 – добавьте в нее код,
    # который добавляет данные в файл JSON (спрашивает их у пользователя) и потом также выводить содержимое итогового файлана экран.
    name = input("Название: ")
    price = input("Цена: ")
    weight = input("Вес: ")
    available = input("Наличие (0 - нет, 1 - есть: ")
    if available == "0":
        available = False
    if available == "1":
        available = True
        # Проверяем корректность значений
    if name != "" and name.isdigit() == False and price.isdigit() == True and weight.isdigit() == True and (available == True or available == False):
        # Создаём словарь из новых данных
        NewDict = {"name": name, "price": price, "weight": weight, "available": available}
        print(NewDict)
        ProductsList.append(NewDict) # Добавляем в конец списка новый словарь
        reader = {"products": ProductsList} # Обновляем ридер новыми данными
        with open(path, 'r+', encoding='utf-8') as JsonFileWrite:  # Открываем файл для записи в переменной JsonFile
            JsonFileWrite.write(json.dumps(reader, sort_keys = False, indent = 4, ensure_ascii = False, separators = (',', ': ')))
    else:
        print("Введены неверные значения!")

def TXT(path, OutputPath): #10.3 Работа с TXT файлами
    # 10.3 Создание русско-английского словаря.
    # Имеется файл en-ru.txt, в котором находятся строки англорусского словаря в таком формате:
    # cat - кошка
    # dog - собака
    # home - домашняя папка, дом
    # mouse - мышь, манипулятор мышь
    # to do - делать, изготавливать
    # to make – изготавливать
    # и т.п.
    # Требуется создать русско-английский словарь и вывести его в файл ru-en.txt в таком формате:
    # делать – to do
    # дом – home
    # домашняя папка – home
    # изготавливать – to do, to make
    # кошка – cat
    # манипулятор мышь – mouse
    # мышь – mouse
    # собака – dog
    with open(path, encoding='utf-8') as TXTFile: # Открываем файл
        file_reader = csv.reader(TXTFile, delimiter="-")  # Создаем объект reader, указываем символ-разделитель ";"
        RuEn={} # Создаём словарь для будущих значений рус-англ
        for row in file_reader:  # Построчно читаем файл в переменную "row"
            ru="" # Обнуляем ключ словаря
            for parse in row[1]: # Разбираем русское слово
                if parse == ",": # Если есть запятая, эначит имеем пару русских значений
                    # А значит нужно и 2 ключа или бльше
                    addons = {ru: row[0]} # Записываем слово, найденное до запятой в переменную и аглийское значение к нему
                    RuEn.update(addons) # Добавляем полученную пару в наш словарь
                    parse="" # Обнуляем переменные, чтобы следующее значение было записано без предыдущего
                    ru = ""
                ru += str(parse) # Записываем найденные во время разбора символы, если не наткнулись на запятую
                # иначе переменная остаётся пустой (из-за обнуления, по условию выше)
            if ru != "": # Если после разбора переменной остались символы - значит, это последний ключ в строке или единственный (запятых не было и условие не выполнилось)
                addons = {ru: row[0]} # Записываем слово, найденное до запятой в переменную и аглийское значение к нему
                RuEn.update(addons) # Добавляем полученную пару в наш словарь
            print(RuEn)
        RuList=list(RuEn.keys()) # Создаём список из русскоязычных ключей
        RuList.sort() # Сортируем полученный список по алфавиту
        print(RuList)
        with open(OutputPath, 'w+', encoding='utf-8') as TXTFile:  # Открываем файл для записи в переменной
            RuListLen=len(RuList) # узнаём количество элементов в списке
            count = 0
            while count != RuListLen:
                TXTFile.write(f' {RuList[count]} - {RuEn.get(RuList[count])}\n') # Записываем ключ - эначение в новый файл
                count += 1

            """11, 12 Лабы. Работы с клвссасми, методами, наследованием и GUI TkInter"""

import tkinter as tk

class Restaurant():
    def __init__(self, restaurant_name, cuisine_type):
        self.restaurant_name = restaurant_name
        self.cuisine_type = cuisine_type
        self.reiting = 0

    def open_restaurant(self):
        print("Ресторан открыт")
        return "Ресторан открыт"

    def describe_restaurant(self):
        print(f'{self.restaurant_name} {self.cuisine_type}')
        return (f'{self.restaurant_name} {self.cuisine_type}')

    def rupdate(self, addr):
        self.reiting += addr
        print(self.reiting)
        return self.reiting


class IceCreamStand(Restaurant):
    def __init__(self, restaurant_name, cuisine_type, flavors, place, time):
        super().__init__(restaurant_name, cuisine_type)
        self.flavors = flavors
        self.place = place
        self.time = time

    def IceCreamTypes(self):
        print(self.flavors)
        Window = tk.Tk()
        Window.title("IceCreamStand")
        ForText = ""
        for text in self.flavors:
            ForText += str(text) + str("\n")
        Label = tk.Label(Window, text=str(ForText))
        Label.grid(column=2, row=1)
        Window.mainloop()
        return self.flavors

    def IceCreamTypesAdd(self, To_Add):
        self.flavors.append(To_Add)
        return self.flavors

    def IceCreamTypesRem(self, To_Del):
        self.flavors.remove(To_Del)
        return self.flavors.remove

    def IceCreamTypesChk(self, To_Chk):
        To_Chk = self.flavors.count(To_Chk)
        if To_Chk > 0:
            print("Есть в наличии")
        else:
            print("Нет в наличии")
        return To_Chk

MyLabs = input("Номер лабы: ")
if MyLabs == "2.1":
    PassCheck() # 2.1 Пользовательский ввод
if MyLabs == "2.2":
    PlaceCheck() # 2.2 Работа с числами
if MyLabs == "2.3":
    YearChk() # 2.3 Продолжение работы с числами
if MyLabs == "2.4":
    MixColor() #  2.4 Продолжение работы с числами
if MyLabs == "3.1": # 3.1 Пользовательский ввод и цикл
    KeyInput()
if MyLabs == "3.2": # 3.2 Пользовательский ввод и цикл с проверкой на введённое слово
    WordChk()
if MyLabs == "3.3": # 3.3 Проверка наличия буквы в слове
    LetChk()
if MyLabs == "3.4": # 3.4 Математическая игра
    MathGame()
if MyLabs == "4.1": # 4.1 Работа с функциями. Деление без остатка
    code(int(input("Делимое")), int(input("Делитель")))
if MyLabs == "4.2": # 4.2 Проверка типа переменной
    print(code(input("Введите число")))
if MyLabs == "4.3": # 4.3 Парсинг числа
    print(code(str(input("Введите дату: число.месяц.год."))))
if MyLabs == "4.4": # 4.4 Счастливый билет. Парсинг числа
    print(code(str(input("Введите номер билета"))))
if MyLabs == "5.1": # 5.1 Работа с рандомайзером
    Numbers = randomizer(5, 0, 98)
    Number = ""
    UserChoice = input("Введите номер: ")
    ParsedCount=0
    EndCount = len(Numbers)
    print(Numbers)
    while ParsedCount <= EndCount:
        if str(Numbers[ParsedCount:ParsedCount +1]) != " ":
            Number = str(Number) + str(Numbers[ParsedCount:ParsedCount + 1])
        else:
            if int(Number) == int(UserChoice):
                print("Вы угадали число - " + str(UserChoice))
            Number = ""
        ParsedCount+=1
if MyLabs == "5.2": # 5.2 Работа с массивами
    Arrays()
if MyLabs == "5.3": # Работа со списками
    Weekends()
if MyLabs == "5.4": # 5.4 Работа со списками
    StudentsTeam()
if MyLabs == "6.1": # 6.1 Работа со словарями
    Countries()
if MyLabs == "6.2": # 6.2 Игра "Эрудит"
    Erudit()
if MyLabs == "6.3": # 6.3 * Расширенная работа со словарём
    Lang()
if MyLabs == "7.1":
    PictShowing("LabFiles/first.jpg") # 7.1 Отобразить любое изображение
    PictPrintInfo("LabFiles/first.jpg") # 7.1 Отобразить информацию о фото
if MyLabs == "7.2":
    PictTransp("LabFiles/first.jpg") # 7.2 Отзеркаливание изображения
if MyLabs == "7.3" or MyLabs == "9.1" or MyLabs == "9.2":
    PictFilterRGB("first.jpg") # 7.3 Наложить фильтр (альтернативный способ)
    PictSharp() # 7.3 Наложить фильтр (альтернативный способ)
if MyLabs == "7.4":
    watermarkPict("1.jpg", "11s.png", "yastreb.ico", 3008, 2200) # 7.4 Накладываем водяной знак на фото:
    # Очерёдность:исходник/выходной файл/файл с водяным знаком/позиция
if MyLabs == "8.1":
    PictCrop("LabFiles/открытка.png", 239, 37, 1280, 853) # 8.1 Обреззка фото
if MyLabs == "8.2" or MyLabs == "8.3":
    Congrats(input("Назовите праздник"), input("Имя получателя"))
if MyLabs == "9.3": # Работа с CSV файлами
    Pokupki("LabFiles/Pokupki.csv")
if MyLabs == "10.1" or MyLabs == "10.2": # Работа с JSON файлами
    JSON('LabFiles/Products.JSON')
if MyLabs == "10.3": # Работа с TXT файлами
    TXT("LabFiles/en-ru.txt", "ru-en.txt")
if MyLabs == "11":  # Работа с классами
    NewRestaurant = Restaurant("Dom", "Китайская")
    ElseRest = Restaurant("The Best", "Японская")
    print(NewRestaurant.restaurant_name)
    print(NewRestaurant.cuisine_type)
    NewRestaurant.describe_restaurant()
    NewRestaurant.open_restaurant()
    ElseRest.describe_restaurant()
    NewRestaurant.rupdate(10)
    NewRestaurant.rupdate(20)
    print(ElseRest.reiting)
if MyLabs == "12":  # Работа с классами
    IceCreamStand = IceCreamStand("Fol", "Русская", ["Кремовое", "ванильное", "клубничное"], "Новочеркасский,45", "10:00 - 22:00")
    IceCreamStand.IceCreamTypes()
    IceCreamStand.IceCreamTypesAdd("шоколадное")
    Types = IceCreamStand.IceCreamTypes()
    print(Types)
